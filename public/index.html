<!DOCTYPE html>
<html lang="zh-CN" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <title>Expenses Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- å¯é€‰å­—ä½“
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
  -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      :root {
        --font-sans: Inter, system-ui, -apple-system, "SF Pro Text", Segoe UI,
          Roboto, "Noto Sans SC", "PingFang SC", "Microsoft YaHei",
          "Noto Sans CJK SC", "Heiti SC", Arial, sans-serif;

        /* Dark */
        --bg: #0c1020;
        --panel: #12182c;
        --panel-soft: #0f1430;
        --muted: #9aa3b2;
        --text: #e8ecf8;
        --border: rgba(255, 255, 255, 0.08);
        --brand: #8b8bff;
        --brand-2: #a78bfa;
        --ok: #33d69f;
        --warn: #f6c452;
        --danger: #f87171;
        --chip: #202845;
        --chip-2: #1a2240;
        --shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
        --radius: 16px;
        --input-bg: #0f1533;
        --badge-bg: #15243f;
        --edit-row-bg: rgba(255, 255, 255, 0.02);

        --fs-xs: clamp(11.5px, 0.25vw + 10px, 12.5px);
        --fs-sm: clamp(12.5px, 0.3vw + 10.5px, 13.8px);
        --fs-base: clamp(14px, 0.35vw + 11px, 15.8px);
        --fs-md: clamp(15px, 0.45vw + 11.5px, 17.2px);
        --fs-lg: clamp(16.5px, 0.55vw + 12px, 19px);
      }
      :root[data-theme="light"] {
        --bg: #f5f7fb;
        --panel: #ffffff;
        --panel-soft: #fafbff;
        --muted: #5b6475;
        --text: #0f172a;
        --border: rgba(0, 0, 0, 0.08);
        --brand: #3b82f6;
        --brand-2: #6366f1;
        --ok: #059669;
        --warn: #eab308;
        --danger: #ef4444;
        --chip: #eef2ff;
        --chip-2: #f3f6ff;
        --shadow: 0 8px 28px rgba(0, 0, 0, 0.08);
        --input-bg: #ffffff;
        --badge-bg: #eef2ff;
        --edit-row-bg: rgba(0, 0, 0, 0.03);
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: var(--font-sans);
        font-size: var(--fs-base);
        line-height: 1.55;
        color: var(--text);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeLegibility;
        background: radial-gradient(
            1200px 600px at 20% -10%,
            #1e275a 0%,
            rgba(30, 39, 90, 0) 55%
          ),
          radial-gradient(
            1000px 700px at 110% 10%,
            #3d1d6d 0%,
            rgba(61, 29, 109, 0) 60%
          ),
          var(--bg);
      }
      html[data-theme="light"] body {
        background: radial-gradient(
            900px 500px at 15% -10%,
            #dfe7ff 0%,
            rgba(223, 231, 255, 0) 60%
          ),
          radial-gradient(
            900px 600px at 110% 10%,
            #f5d9ff 0%,
            rgba(245, 217, 255, 0) 60%
          ),
          var(--bg);
      }
      .wrap {
        max-width: 1100px;
        margin: 28px auto;
        padding: 0 18px;
      }
      .card {
        background: linear-gradient(
          180deg,
          var(--panel) 0%,
          var(--panel-soft) 100%
        );
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 18px;
        margin-bottom: 18px;
      }
      .toolbar {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }
      .toolbar .right {
        margin-left: auto;
        display: flex;
        gap: 10px;
        align-items: center;
      }
      h3 {
        font-size: var(--fs-lg);
        margin: 0 0 10px 0;
        letter-spacing: 0.2px;
      }
      .muted {
        color: var(--muted);
        font-size: var(--fs-xs);
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        border-radius: 999px;
        background: var(--chip);
        border: 1px solid var(--border);
        font-size: var(--fs-sm);
        color: inherit;
      }
      .ai-pill {
        background: linear-gradient(90deg, #2b2f66, #2a1b57);
        border-color: #3d3e7a;
      }
      :root[data-theme="light"] .ai-pill {
        background: linear-gradient(90deg, #edf2ff, #f5f0ff);
        border-color: #e4e7ff;
      }
      .ai-pill .star {
        display: inline-grid;
        place-items: center;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--brand);
        color: #0b0f24;
        font-weight: 700;
      }
      input,
      button {
        font: inherit;
        color: var(--text);
      }
      input,
      select {
        background: var(--input-bg);
        border: 1px solid var(--border);
        color: var(--text);
        padding: 9px 12px;
        border-radius: 12px;
        outline: none;
        font-size: var(--fs-sm);
      }
      input::placeholder {
        color: #7f8aa8;
        opacity: 0.9;
      }
      .btn {
        padding: 9px 14px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--panel-soft);
        cursor: pointer;
        font-size: var(--fs-sm);
      }
      .btn:hover {
        filter: brightness(1.05);
      }
      .btn.primary {
        border-color: var(--brand);
        box-shadow: inset 0 0 0 1px
          color-mix(in oklab, var(--brand) 25%, transparent);
      }
      .btn.danger {
        border-color: var(--danger);
        box-shadow: inset 0 0 0 1px
          color-mix(in oklab, var(--danger) 25%, transparent);
      }
      .summary {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .summary .kv {
        background: var(--chip-2);
        border: 1px solid var(--border);
        padding: 8px 12px;
        border-radius: 10px;
        font-size: var(--fs-sm);
      }
      .summary .kv b {
        color: inherit;
      }
      .hr {
        height: 1px;
        background: var(--border);
        margin: 10px 0 4px;
      }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        table-layout: fixed;
      }
      thead th {
        font-weight: 600;
        text-align: left;
        padding: 12px 10px;
        border-bottom: 1px solid var(--border);
        color: var(--text);
        position: sticky;
        top: 0;
        background: linear-gradient(180deg, #141a36 0%, #12182c 80%);
        z-index: 1;
        font-size: var(--fs-sm);
      }
      html[data-theme="light"] thead th {
        background: linear-gradient(180deg, #f8fbff 0%, #ffffff 80%);
      }
      tbody td {
        padding: 12px 10px;
        border-bottom: 1px solid var(--border);
        color: inherit;
        vertical-align: top;
        font-size: var(--fs-sm);
      }
      tbody tr.editing td {
        padding: 10px 10px;
        background: var(--edit-row-bg);
      }
      .right {
        text-align: right;
      }
      .nowrap {
        white-space: nowrap;
      }
      .ellipsis {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: block;
      }
      .amount {
        font-variant-numeric: tabular-nums;
        font-feature-settings: "tnum", "cv02", "cv03", "ss01";
        letter-spacing: 0.2px;
      }
      .amount.badge {
        display: inline-flex;
        padding: 4px 8px;
        border-radius: 999px;
        background: var(--badge-bg);
        border: 1px solid var(--border);
      }
      .category-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        background: var(--chip);
        border: 1px solid var(--border);
        font-size: 12px;
      }
      .row-actions {
        display: flex;
        gap: 8px;
      }
      .empty {
        color: var(--muted);
        text-align: center;
        padding: 28px 0;
      }
      .sort-btn {
        cursor: pointer;
        user-select: none;
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }
      .sort-icon {
        opacity: 0.5;
      }
      .sort-active .sort-icon {
        opacity: 1;
      }
      .note {
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
      .note.expanded {
        -webkit-line-clamp: unset;
      }
      .link {
        color: var(--brand-2);
        cursor: pointer;
        font-size: var(--fs-xs);
      }
      .table-input {
        width: 100%;
        min-width: 0;
        height: 36px;
        padding: 6px 10px;
        border-radius: 10px;
        background: var(--input-bg);
        border: 1px solid var(--border);
        color: var(--text);
        font-size: var(--fs-sm);
        outline: none;
      }
      .table-input:focus {
        box-shadow: 0 0 0 2px color-mix(in oklab, var(--brand) 30%, transparent);
      }
      .table-input.amount-input {
        text-align: right;
        font-variant-numeric: tabular-nums;
        font-feature-settings: "tnum", "cv02", "cv03", "ss01";
      }

      /* Chart card */
      .chart-wrap {
        height: 340px;
        position: relative;
      }
      .chart-toolbar {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }
    </style>
  </head>
  <body>
    <div id="app" class="wrap">
      <!-- Top Controls -->
      <div class="card">
        <div class="toolbar">
          <div class="pill ai-pill">
            <span class="star">â˜…</span>
            <div>
              <div class="muted" style="line-height: 1.2">Monthly Summary</div>
              <div style="font-size: var(--fs-sm)">{{ summaryText }}</div>
            </div>
          </div>

          <div class="right">
            <label class="muted">Month:&nbsp;</label>
            <input type="month" v-model="month" @change="onMonthChange" />
            <input
              placeholder="Search payee/category/note"
              v-model.trim="q"
              @keyup.enter="resetPageAndReload"
              style="min-width: 280px"
            />
            <button class="btn" @click="resetPageAndReload">Search</button>
            <span class="muted"
              >Showing {{expenses.length}} / {{total}} items</span
            >
            <button class="btn" @click="prevPage" :disabled="page<=1">
              Prev
            </button>
            <span class="muted">Page {{page}} / {{pages}}</span>
            <button class="btn" @click="nextPage" :disabled="page>=pages">
              Next
            </button>
            <button class="btn" @click="toggleTheme" :title="themeBtnTitle">
              {{ themeIcon }} {{ themeBtnText }}
            </button>
          </div>
        </div>

        <div class="hr"></div>
        <div class="summary" v-if="categorySummary.length">
          <div class="kv"><b>Total:</b> {{ fmtMoney(monthTotal) }}</div>
          <div class="kv"><b>Entries:</b> {{ total }}</div>
          <div class="kv">
            <b>Top category:</b> {{ topCategoryName }} ({{
            fmtMoney(topCategoryTotal) }})
          </div>
          <div class="kv"><b>Range:</b> {{ rangeText }}</div>
          <div class="kv muted">
            Tip: click column headers to sort; use the search to filter.
          </div>
        </div>
      </div>

      <!-- Charts -->
      <div class="card">
        <h3>Charts</h3>
        <div class="chart-toolbar">
          <select v-model="chartType" @change="buildChart">
            <option value="category">By Category (Donut)</option>
            <option value="daily">Daily Total (Stacked)</option>
            <option value="cumulative">Cumulative (Line)</option>
          </select>

          <span class="muted">Range:</span>
          <select v-model="chartRangeMode" @change="onChartRangeModeChange">
            <option value="monthly">Monthly (default)</option>
            <option value="custom">Custom</option>
          </select>

          <template v-if="chartRangeMode==='custom'">
            <input type="date" v-model="chartStartDate" />
            <span>~</span>
            <input type="date" v-model="chartEndDate" />
            <button class="btn" @click="applyCustomRange">Apply</button>
          </template>

          <button class="btn" @click="buildChart">Refresh</button>
          <span class="muted">Data range: {{ chartRangeText }}</span>
        </div>
        <div class="chart-wrap">
          <canvas id="expChart"></canvas>
        </div>
      </div>

      <!-- Add -->
      <div class="card">
        <h3>Add Expense</h3>
        <div style="display: flex; gap: 10px; flex-wrap: wrap">
          <input type="datetime-local" v-model="newItem.time" />
          <input
            type="number"
            step="0.01"
            placeholder="Amount"
            v-model.number="newItem.amount"
          />
          <select v-model="newItem.category">
            <option v-for="c in categoryOptions" :key="c" :value="c">
              {{ c || 'Uncategorized' }}
            </option>
          </select>
          <input placeholder="Payee" v-model.trim="newItem.payee" />
          <input
            placeholder="Note"
            v-model.trim="newItem.note"
            style="min-width: 240px"
          />
          <button class="btn primary" @click="create">Add</button>
        </div>
      </div>

      <!-- Table -->
      <div class="card" style="padding: 0">
        <table>
          <colgroup>
            <col style="width: 170px" />
            <col style="width: 110px" />
            <col style="width: 140px" />
            <col />
            <col />
            <col style="width: 150px" />
          </colgroup>
          <thead>
            <tr>
              <th class="nowrap">
                <span
                  class="sort-btn"
                  :class="{'sort-active': sortKey==='time'}"
                  @click="toggleSort('time')"
                >
                  Date
                  <span class="sort-icon"
                    >{{ sortKey==='time' ? (sortDir==='asc' ? 'â–²' : 'â–¼') : 'â†•'
                    }}</span
                  ></span
                >
              </th>
              <th class="right nowrap">
                <span
                  class="sort-btn"
                  :class="{'sort-active': sortKey==='amount'}"
                  @click="toggleSort('amount')"
                >
                  Amount
                  <span class="sort-icon"
                    >{{ sortKey==='amount' ? (sortDir==='asc' ? 'â–²' : 'â–¼') : 'â†•'
                    }}</span
                  ></span
                >
              </th>
              <th class="nowrap">
                <span
                  class="sort-btn"
                  :class="{'sort-active': sortKey==='category'}"
                  @click="toggleSort('category')"
                >
                  Category
                  <span class="sort-icon"
                    >{{ sortKey==='category' ? (sortDir==='asc' ? 'â–²' : 'â–¼') :
                    'â†•' }}</span
                  ></span
                >
              </th>
              <th class="nowrap">
                <span
                  class="sort-btn"
                  :class="{'sort-active': sortKey==='payee'}"
                  @click="toggleSort('payee')"
                >
                  Payee
                  <span class="sort-icon"
                    >{{ sortKey==='payee' ? (sortDir==='asc' ? 'â–²' : 'â–¼') : 'â†•'
                    }}</span
                  ></span
                >
              </th>
              <th>Note</th>
              <th class="nowrap">Actions</th>
            </tr>
          </thead>
          <tbody>
            <tr
              v-for="row in sortedExpenses"
              :key="row._id"
              :class="{ editing: row._editing }"
            >
              <td class="nowrap">
                <template v-if="row._editing"
                  ><input
                    type="datetime-local"
                    class="table-input"
                    v-model="row._edit.time"
                /></template>
                <template v-else
                  ><span class="ellipsis"
                    >{{ fmtDate(row.time) }}</span
                  ></template
                >
              </td>
              <td class="right amount">
                <template v-if="row._editing"
                  ><input
                    type="number"
                    step="0.01"
                    class="table-input amount-input"
                    v-model.number="row._edit.amount"
                /></template>
                <template v-else
                  ><span class="amount badge"
                    >{{ fmtMoney(row.amount) }}</span
                  ></template
                >
              </td>
              <td>
                <template v-if="row._editing">
                  <select class="table-input" v-model="row._edit.category">
                    <option v-for="c in categoryOptions" :key="c" :value="c">
                      {{ c || 'Uncategorized' }}
                    </option>
                  </select>
                </template>
                <template v-else
                  ><span class="category-chip"
                    ># {{ row.category || 'Uncategorized' }}</span
                  ></template
                >
              </td>
              <td>
                <template v-if="row._editing"
                  ><input class="table-input" v-model="row._edit.payee"
                /></template>
                <template v-else
                  ><span class="ellipsis">{{ row.payee }}</span></template
                >
              </td>
              <td>
                <template v-if="row._editing"
                  ><input class="table-input" v-model="row._edit.note"
                /></template>
                <template v-else>
                  <div :class="['note', {expanded: row._expand}]">
                    {{ row.note }}
                  </div>
                  <div
                    v-if="row.note && row.note.length>40"
                    class="link"
                    @click="row._expand=!row._expand"
                  >
                    {{ row._expand ? 'Show less' : 'Show more' }}
                  </div>
                </template>
              </td>
              <td>
                <div class="row-actions" v-if="!row._editing">
                  <button class="btn" @click="beginEdit(row)">Edit</button>
                  <button class="btn danger" @click="del(row)">Delete</button>
                </div>
                <div class="row-actions" v-else>
                  <button class="btn primary" @click="save(row)">Save</button>
                  <button class="btn" @click="cancel(row)">Cancel</button>
                </div>
              </td>
            </tr>
            <tr v-if="!sortedExpenses.length">
              <td colspan="6" class="empty">No data</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <script>
      const { createApp, ref, computed, onMounted, onBeforeUnmount } = Vue;

      createApp({
        setup() {
          const API_BASE = ""; // same-origin
          const API_KEY = ""; // set if server uses API_KEY
          const headers = () => {
            const h = { "Content-Type": "application/json" };
            if (API_KEY) h["x-api-key"] = API_KEY;
            return h;
          };

          // ---------- Theme ----------
          const initialTheme = (() => {
            const saved = localStorage.getItem("theme");
            if (saved === "light" || saved === "dark") return saved;
            return window.matchMedia &&
              window.matchMedia("(prefers-color-scheme: light)").matches
              ? "light"
              : "dark";
          })();
          const theme = ref(initialTheme);
          applyTheme(theme.value);
          function applyTheme(t) {
            document.documentElement.setAttribute("data-theme", t);
            localStorage.setItem("theme", t);
          }
          function toggleTheme() {
            theme.value = theme.value === "light" ? "dark" : "light";
            applyTheme(theme.value);
            buildChart();
          }
          const themeIcon = computed(() =>
            theme.value === "light" ? "ðŸŒ™" : "ðŸŒž"
          );
          const themeBtnText = computed(() =>
            theme.value === "light" ? "å¤œé—´æ¨¡å¼" : "æ—¥é—´æ¨¡å¼"
          );
          const themeBtnTitle = computed(() => "åˆ‡æ¢é¡µé¢ä¸»é¢˜");

          // ---------- State ----------
          const month = ref(new Date().toISOString().slice(0, 7)); // YYYY-MM
          const q = ref("");
          const page = ref(1);
          const limit = ref(50);
          const expenses = ref([]);
          const total = ref(0);
          const pages = ref(1);

          // Build a datetime-local value for "now" in local timezone
          function nowLocalInput() {
            const d = new Date();
            const off = d.getTimezoneOffset();
            const local = new Date(d.getTime() - off * 60000);
            return local.toISOString().slice(0, 16);
          }

          const newItem = ref({
            // Use local time (UTC+8 expected) for input default
            time: nowLocalInput(),
            amount: null,
            category: "Uncategorized",
            payee: "",
            note: "",
          });

          const categorySummary = ref([]);
          // Category options for dropdown (merge defaults + observed)
          const defaultCategories = [
            "è½¬è´¦",
            "ç”Ÿæ´»ç¼´è´¹",
            "å‡ºè¡Œ",
            "é¤é¥®",
            "è´­ç‰©",
            "æ•°ç ",
            "å¨±ä¹",
            "é€šè®¯",
            "åŒ»ç–—",
            "å…¶ä»–",
            "Uncategorized",
          ];
          const categoryOptions = computed(() => {
            const set = new Set(defaultCategories);
            // from current table data
            for (const r of expenses.value) if (r.category) set.add(r.category);
            // from summary (top categories this month)
            for (const s of categorySummary.value)
              if (s && s.category) set.add(s.category);
            // ensure "Uncategorized" exists
            set.add("Uncategorized");
            // keep default order first, then others alphabetically
            const rest = [...set].filter((c) => !defaultCategories.includes(c));
            rest.sort((a, b) => a.localeCompare(b));
            return [...defaultCategories, ...rest].filter(
              (v, i, arr) => arr.indexOf(v) === i
            );
          });
          const monthTotal = computed(() =>
            categorySummary.value.reduce((s, c) => s + (c.total || 0), 0)
          );
          const topCategory = computed(
            () => categorySummary.value[0] || { category: "-", total: 0 }
          );
          const topCategoryName = computed(
            () => topCategory.value.category || "-"
          );
          const topCategoryTotal = computed(() => topCategory.value.total || 0);

          const chartType = ref("category");
          const chartRangeMode = ref("monthly"); // 'monthly' | 'custom'
          const chartStartDate = ref(""); // YYYY-MM-DD
          const chartEndDate = ref(""); // YYYY-MM-DD
          const chartDataAll = ref([]); // all items in chosen range for charts
          let chart; // Chart.js instance

          function rangeFromMonth(ym) {
            const [y, m] = ym.split("-").map((n) => parseInt(n, 10));
            const start = new Date(Date.UTC(y, m - 1, 1, 0, 0, 0));
            const end = new Date(Date.UTC(y, m, 0, 23, 59, 59, 999));
            return { start: start.toISOString(), end: end.toISOString(), y, m };
          }
          const rangeText = computed(() => {
            const { start, end } = rangeFromMonth(month.value);
            const s = new Date(start),
              e = new Date(end);
            return `${s.getUTCFullYear()}-${pad(
              s.getUTCMonth() + 1
            )}-01 ~ ${e.getUTCFullYear()}-${pad(e.getUTCMonth() + 1)}-${pad(
              e.getUTCDate()
            )}`;
          });
          const chartRangeText = computed(() => {
            if (chartRangeMode.value === "monthly") return rangeText.value;
            if (!chartStartDate.value || !chartEndDate.value) return "-";
            return `${chartStartDate.value} ~ ${chartEndDate.value}`;
          });
          const summaryText = computed(
            () =>
              `Total ${total.value} entries Â· Sum ${fmtMoney(
                monthTotal.value
              )} Â· Top: ${topCategoryName.value}`
          );

          // ---------- Data fetch ----------
          async function reload() {
            const { start, end } = rangeFromMonth(month.value);
            // paginated for table
            const url = new URL(
              API_BASE + "/api/expenses",
              window.location.origin
            );
            url.searchParams.set("start", start);
            url.searchParams.set("end", end);
            url.searchParams.set("page", page.value);
            url.searchParams.set("limit", limit.value);
            if (q.value) url.searchParams.set("q", q.value);
            const res = await fetch(url, { headers: headers() });
            if (!res.ok) {
              alert("Fetch failed");
              return;
            }
            const json = await res.json();
            total.value = json.total;
            pages.value = json.pages;
            expenses.value = json.data.map((row) => ({
              ...row,
              _editing: false,
              _edit: null,
              _expand: false,
            }));

            // category summary
            const su = new URL(
              API_BASE + "/api/stats/category",
              window.location.origin
            );
            su.searchParams.set("start", start);
            su.searchParams.set("end", end);
            const res2 = await fetch(su, { headers: headers() });
            categorySummary.value = res2.ok ? await res2.json() : [];

            // Load chart data for selected range and build chart
            await loadChartData();
            buildChart();
          }
          function resetPageAndReload() {
            page.value = 1;
            reload();
          }
          function prevPage() {
            if (page.value > 1) {
              page.value--;
              reload();
            }
          }
          function nextPage() {
            if (page.value < pages.value) {
              page.value++;
              reload();
            }
          }
          function onMonthChange() {
            resetPageAndReload();
          }

          async function create() {
            if (!newItem.value.amount || !newItem.value.time)
              return alert("amount & time required");
            // Convert the local datetime-local string to an ISO string
            // and include tz so the server formats time_local as UTC+8.
            const localDate = new Date(newItem.value.time);
            const body = {
              amount: Number(newItem.value.amount),
              category: newItem.value.category,
              payee: newItem.value.payee,
              note: newItem.value.note,
              source: "web",
              time: localDate.toISOString(),
              tz: "Asia/Shanghai",
            };
            const res = await fetch(API_BASE + "/api/expenses", {
              method: "POST",
              headers: headers(),
              body: JSON.stringify(body),
            });
            if (!res.ok) return alert("Create failed");
            newItem.value.amount = null;
            newItem.value.payee = "";
            newItem.value.note = "";
            // Keep the chosen time; user can change if needed
            resetPageAndReload();
          }

          // ---------- Inline edit ----------
          function toLocalInputValue(dt) {
            const d = new Date(dt);
            const off = d.getTimezoneOffset();
            const local = new Date(d.getTime() - off * 60000);
            return local.toISOString().slice(0, 16);
          }
          function beginEdit(row) {
            row._editing = true;
            row._edit = {
              time: toLocalInputValue(row.time),
              amount: row.amount,
              category: row.category || "Uncategorized",
              payee: row.payee || "",
              note: row.note || "",
            };
          }
          function cancel(row) {
            row._editing = false;
            row._edit = null;
          }
          async function save(row) {
            const body = { ...row._edit, amount: Number(row._edit.amount) };
            const res = await fetch(API_BASE + "/api/expenses/" + row._id, {
              method: "PATCH",
              headers: headers(),
              body: JSON.stringify(body),
            });
            if (!res.ok) return alert("Update failed");
            row._editing = false;
            row._edit = null;
            reload();
          }
          async function del(row) {
            if (!confirm("Delete this expense?")) return;
            const res = await fetch(API_BASE + "/api/expenses/" + row._id, {
              method: "DELETE",
              headers: headers(),
            });
            if (!res.ok) return alert("Delete failed");
            reload();
          }

          // ---------- Sorting ----------
          const sortKey = ref("time");
          const sortDir = ref("desc");
          function toggleSort(key) {
            if (sortKey.value === key) {
              sortDir.value = sortDir.value === "asc" ? "desc" : "asc";
            } else {
              sortKey.value = key;
              sortDir.value = "desc";
            }
          }
          const sortedExpenses = computed(() => {
            const arr = expenses.value.slice();
            const dir = sortDir.value === "asc" ? 1 : -1;
            const key = sortKey.value;
            arr.sort((a, b) => {
              let va, vb;
              if (key === "time") {
                va = new Date(a.time).getTime();
                vb = new Date(b.time).getTime();
              } else if (key === "amount") {
                va = Number(a.amount) || 0;
                vb = Number(b.amount) || 0;
              } else {
                va = (a[key] || "").toString().toLowerCase();
                vb = (b[key] || "").toString().toLowerCase();
              }
              if (va < vb) return -1 * dir;
              if (va > vb) return 1 * dir;
              return 0;
            });
            return arr;
          });

          // ---------- Charts ----------
          function getCss(name) {
            return getComputedStyle(document.documentElement)
              .getPropertyValue(name)
              .trim();
          }
          function palette(n) {
            // generate harmonious HSL colors anchored to --brand
            const base = theme.value === "light" ? 230 : 250; // hue
            const arr = [];
            for (let i = 0; i < n; i++) {
              const hue = (base + i * 37) % 360;
              const s = theme.value === "light" ? 70 : 55;
              const l = theme.value === "light" ? 60 : 55;
              arr.push(`hsl(${hue} ${s}% ${l}%)`);
            }
            return arr;
          }

          function buildChart() {
            const ctx = document.getElementById("expChart");
            if (!ctx) return;
            if (chart) {
              chart.destroy();
              chart = null;
            }

            const grid = getCss("--border") || "rgba(0,0,0,.1)";
            const text = getCss("--text") || "#222";

            if (chartType.value === "category") {
              const labels = categorySummary.value.map(
                (x) => x.category || "Uncategorized"
              );
              const data = categorySummary.value.map((x) => x.total || 0);
              const colors = palette(labels.length);
              chart = new Chart(ctx, {
                type: "doughnut",
                data: {
                  labels,
                  datasets: [{ data, backgroundColor: colors, borderWidth: 0 }],
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: { legend: { labels: { color: text } } },
                },
              });
              return;
            }

            // daily totals / cumulative for selected range
            // Determine local start/end
            let rStart, rEnd;
            if (chartRangeMode.value === "monthly") {
              const r = rangeFromMonth(month.value);
              rStart = new Date(r.start);
              rEnd = new Date(r.end);
            } else {
              if (!chartStartDate.value || !chartEndDate.value) return;
              rStart = new Date(`${chartStartDate.value}T00:00:00`);
              rEnd = new Date(`${chartEndDate.value}T23:59:59.999`);
            }
            const startMid = new Date(
              rStart.getFullYear(),
              rStart.getMonth(),
              rStart.getDate()
            );
            const endMid = new Date(
              rEnd.getFullYear(),
              rEnd.getMonth(),
              rEnd.getDate()
            );
            const dayMs = 24 * 60 * 60 * 1000;
            const days = Math.floor((endMid - startMid) / dayMs) + 1;
            const daily = Array.from({ length: Math.max(days, 0) }, () => 0);

            for (const it of chartDataAll.value) {
              if (!it.time) continue;
              const d = new Date(it.time);
              const dMid = new Date(d.getFullYear(), d.getMonth(), d.getDate());
              const idx = Math.floor((dMid - startMid) / dayMs);
              if (idx >= 0 && idx < daily.length)
                daily[idx] += Number(it.amount) || 0;
            }
            const labels = Array.from({ length: daily.length }, (_, i) => `${i + 1}`);
            if (chartType.value === "daily") {
              // Build stacked series by category per day
              const catSet = new Set();
              const catTotals = new Map();
              const catData = new Map(); // cat -> Array(days).fill(0)
              for (const it of chartDataAll.value) {
                if (!it.time) continue;
                const d = new Date(it.time);
                const dMid = new Date(d.getFullYear(), d.getMonth(), d.getDate());
                const idx = Math.floor((dMid - startMid) / dayMs);
                if (idx < 0 || idx >= daily.length) continue;
                const cat = (it.category || "Uncategorized").toString();
                if (!catData.has(cat)) {
                  catData.set(cat, Array.from({ length: daily.length }, () => 0));
                  catTotals.set(cat, 0);
                }
                const arr = catData.get(cat);
                const amt = Number(it.amount) || 0;
                arr[idx] += amt;
                catTotals.set(cat, (catTotals.get(cat) || 0) + amt);
                catSet.add(cat);
              }
              const cats = Array.from(catSet);
              // Sort categories by total desc for consistent stacking
              cats.sort((a, b) => (catTotals.get(b) || 0) - (catTotals.get(a) || 0));
              const colors = palette(cats.length);
              const datasets = cats.map((cat, i) => ({
                label: cat || "Uncategorized",
                data: catData.get(cat) || Array.from({ length: daily.length }, () => 0),
                backgroundColor: colors[i],
                stack: "total",
                borderWidth: 0,
              }));
              chart = new Chart(ctx, {
                type: "bar",
                data: { labels, datasets },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  interaction: { mode: "index", intersect: false },
                  scales: {
                    x: { grid: { color: grid }, ticks: { color: text }, stacked: true },
                    y: { grid: { color: grid }, ticks: { color: text }, stacked: true },
                  },
                  plugins: {
                    legend: { labels: { color: text } },
                    tooltip: {
                      // Show all categories for the hovered day
                      filter: (item) => (item.parsed.y || 0) !== 0,
                      callbacks: {
                        title: (items) => {
                          const idx = items?.[0]?.dataIndex ?? 0;
                          const dt = new Date(startMid.getTime() + idx * dayMs);
                          const y = dt.getFullYear();
                          const m = String(dt.getMonth() + 1).padStart(2, "0");
                          const d = String(dt.getDate()).padStart(2, "0");
                          const dayNo = idx + 1;
                          return `${y}-${m}-${d} (Day ${dayNo})`;
                        },
                        label: (c) => ` ${c.dataset.label}: ${fmtMoney(c.parsed.y)}`,
                        footer: (items) => {
                          const sum = items.reduce((s, it) => s + (it.parsed.y || 0), 0);
                          return `Total: ${fmtMoney(sum)}`;
                        },
                      },
                    },
                  },
                },
              });
            } else {
              const cum = daily.slice();
              for (let i = 1; i < cum.length; i++) cum[i] += cum[i - 1];
              chart = new Chart(ctx, {
                type: "line",
                data: {
                  labels,
                  datasets: [
                    {
                      label: "Cumulative",
                      data: cum,
                      fill: false,
                      borderWidth: 2,
                      borderColor: palette(1)[0],
                      pointRadius: 2,
                    },
                  ],
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    x: { grid: { color: grid }, ticks: { color: text } },
                    y: { grid: { color: grid }, ticks: { color: text } },
                  },
                  plugins: {
                    legend: { labels: { color: text } },
                    tooltip: {
                      callbacks: { label: (c) => ` ${fmtMoney(c.parsed.y)}` },
                    },
                  },
                },
              });
            }
          }

          function handleResize() {
            buildChart();
          }
          onMounted(() => window.addEventListener("resize", handleResize));
          onBeforeUnmount(() =>
            window.removeEventListener("resize", handleResize)
          );

          // ---------- utils ----------
          function pad(n) {
            return String(n).padStart(2, "0");
          }
          function fmtDate(x) {
            if (!x) return "";
            const d = new Date(x);
            const P = (n) => String(n).padStart(2, "0");
            return `${d.getFullYear()}-${P(d.getMonth() + 1)}-${P(
              d.getDate()
            )} ${P(d.getHours())}:${P(d.getMinutes())}`;
          }
          function fmtMoney(n) {
            return Number(n || 0).toLocaleString(undefined, {
              minimumFractionDigits: 2,
              maximumFractionDigits: 2,
            });
          }

          function toIsoStartOfDay(ymd) {
            const d = new Date(`${ymd}T00:00:00`);
            return d.toISOString();
          }
          function toIsoEndOfDay(ymd) {
            const d = new Date(`${ymd}T23:59:59.999`);
            return d.toISOString();
          }
          async function loadChartData() {
            let startIso, endIso;
            if (chartRangeMode.value === "monthly") {
              const { start, end } = rangeFromMonth(month.value);
              startIso = start;
              endIso = end;
            } else {
              if (!chartStartDate.value || !chartEndDate.value) {
                chartDataAll.value = [];
                return;
              }
              startIso = toIsoStartOfDay(chartStartDate.value);
              endIso = toIsoEndOfDay(chartEndDate.value);
            }
            const all = new URL(
              API_BASE + "/api/expenses",
              window.location.origin
            );
            all.searchParams.set("start", startIso);
            all.searchParams.set("end", endIso);
            all.searchParams.set("page", 1);
            all.searchParams.set("limit", 5000);
            const res = await fetch(all, { headers: headers() });
            const j = res.ok ? await res.json() : { data: [] };
            chartDataAll.value = j.data || [];
          }
          function onChartRangeModeChange() {
            if (chartRangeMode.value === "monthly") {
              loadChartData().then(buildChart);
            }
          }
          function applyCustomRange() {
            if (!chartStartDate.value || !chartEndDate.value) {
              alert("Please select start and end dates");
              return;
            }
            loadChartData().then(buildChart);
          }

          // ---------- init ----------
          reload();

          return {
            // Theme
            themeIcon,
            themeBtnText,
            themeBtnTitle,
            toggleTheme,
            // Filters / table
            month,
            q,
            page,
            pages,
            expenses,
            total,
            categorySummary,
            categoryOptions,
            monthTotal,
            topCategoryName,
            topCategoryTotal,
            rangeText,
            summaryText,
            newItem,
            reload,
            resetPageAndReload,
            prevPage,
            nextPage,
            onMonthChange,
            create,
            beginEdit,
            cancel,
            save,
            del,
            fmtDate,
            fmtMoney,
            sortedExpenses,
            sortKey,
            sortDir,
            toggleSort,
            // Charts
            chartType,
            chartRangeMode,
            chartStartDate,
            chartEndDate,
            chartRangeText,
            applyCustomRange,
            onChartRangeModeChange,
            buildChart,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
